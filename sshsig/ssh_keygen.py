from __future__ import annotations

import argparse
import io
import sys
from collections.abc import Iterable
from pathlib import Path
from typing import BinaryIO, cast
from warnings import warn

from .allowed_signers import AllowedSigner, load_allowed_signers_file
from .ssh_public_key import InvalidSignature, PublicKey
from .sshsig import SshsigSignature, sshsig_verify


def check_novalidate(
    msg_in: str | bytes | BinaryIO, namespace: str, armored_signature: str
) -> PublicKey:
    """Check that a ssh-keygen signature has a valid structure.

    This function implements functionality provided by:
    ```
    ssh-keygen -Y check-novalidate -n namespace -s armored_signature_file < msg_in
    ```
    """

    if isinstance(msg_in, str):
        msg_in = msg_in.encode()
    msg_file = io.BytesIO(msg_in) if isinstance(msg_in, bytes) else msg_in
    try:
        sshsig_outer = SshsigSignature.from_armored(armored_signature)
    except ValueError as ex:
        raise InvalidSignature(ex)
    return sshsig_verify(sshsig_outer, msg_file, namespace)


def check_allowed_key(
    allowed: AllowedSigner, pub_key: PublicKey, principal: str, namespace: str
) -> bool:
    if allowed.principals != "*":
        msg = "Only solitary wildcard principal pattern supported."
        raise NotImplementedError(msg)
    options = allowed.options or dict()
    if "cert-authority" in options:
        warn("Certificate keys not supported in this implementation.")
        return False
    if "valid-before" in options or "valid-after" in options:
        raise NotImplementedError("Allowed signer validation dates not implemented.")
    if allowed.key != pub_key:
        return False
    if only_namespaces := options.get("namespaces"):
        if namespace not in cast(list[str], only_namespaces):
            return False
    return True


def verify(
    msg_in: str | bytes | BinaryIO,
    allowed_signers: Iterable[AllowedSigner],
    signer_identity: str,
    namespace: str,
    armored_signature: str,
) -> None:
    """Verify a signature generated by ssh-keygen, the OpenSSH authentication key utility.

    This function implements functionality provided by:
    ```
    ssh-keygen -Y verify \
        -f allowed_signers_file \
        -I signer_identity \
        -n namespace -s armored_signature_file \
        < msg_in
    ```
    """

    pub_key = check_novalidate(msg_in, namespace, armored_signature)
    for allowed in allowed_signers:
        if check_allowed_key(allowed, pub_key, signer_identity, namespace):
            return
    raise InvalidSignature("Signature public key not of allowed signer.")


def cli_subcmd_check_novalidate(
    msg_in: BinaryIO,
    namespace: str,
    signature_file: Path,
) -> int:
    try:
        with open(signature_file) as f:
            check_novalidate(msg_in, namespace, f.read())
        return 0
    except InvalidSignature as ex:
        print(ex, file=sys.stderr)
        return 255


def cli_subcmd_verify(
    msg_in: BinaryIO,
    allowed_signers_file: Path,
    signer_identity: str,
    namespace: str,
    signature_file: Path,
) -> int:
    allowed = load_allowed_signers_file(allowed_signers_file)
    try:
        with open(signature_file) as f:
            verify(msg_in, allowed, signer_identity, namespace, f.read())
        return 0
    except InvalidSignature as ex:
        print(ex, file=sys.stderr)
        return 255


def main(stdin: BinaryIO, args: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        description="Test reimplementation of ssh-keygen -Y"
    )
    parser.add_argument("-Y", action="store_true", required=True)
    subparsers = parser.add_subparsers(dest="subcmd", required=True)

    check_parser = subparsers.add_parser(
        "check-novalidate", help="Check signature has valid structure."
    )
    check_parser.add_argument("-O", dest="option", help="not implemented")
    check_parser.add_argument("-n", dest="namespace", required=True)
    check_parser.add_argument("-s", dest="signature_file", type=Path, required=True)

    verify_parser = subparsers.add_parser("verify", help="verify a signature")
    verify_parser.add_argument("-O", dest='option', help="not implemented")
    verify_parser.add_argument(
        "-f", dest='allowed_signers_file', type=Path, required=True
    )
    verify_parser.add_argument("-I", dest='signer_identity', required=True)
    verify_parser.add_argument("-n", dest='namespace', required=True)
    verify_parser.add_argument("-s", dest='signature_file', type=Path, required=True)
    verify_parser.add_argument("-r", dest='revocation_file', help="not implemented")

    noms = parser.parse_args(args)

    if noms.option:
        print("ssh-keygen -O option is not implemented.", file=sys.stderr)
        return 2

    if noms.subcmd == "check-novalidate":
        return cli_subcmd_check_novalidate(stdin, noms.namespace, noms.signature_file)
    if noms.subcmd == "verify":
        if noms.revocation_file:
            print("ssh-keygen verify -r option is not implemented.", file=sys.stderr)
            return 2
        return cli_subcmd_verify(
            stdin,
            noms.allowed_signers_file,
            noms.signer_identity,
            noms.namespace,
            noms.signature_file,
        )
    errmsg = "Only verify and check-novalidate subcommands are supported."
    print(errmsg, file=sys.stderr)
    return 2


if __name__ == "__main__":
    exit(main(sys.stdin.buffer))
